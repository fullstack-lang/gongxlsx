// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"errors"
	"fmt"
	"log"
	"sort"
	"time"

	"github.com/jinzhu/gorm"

	"github.com/fullstack-lang/gongxslx/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_XLSheet sql.NullBool
var __XLSheet_time__dummyDeclaration time.Duration
var dummy_XLSheet_sort sort.Float64Slice

// XLSheetAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model xlsheetAPI
type XLSheetAPI struct {
	models.XLSheet

	// insertion for fields declaration
	// Declation for basic field xlsheetDB.Name {{BasicKind}} (to be completed)
	Name_Data sql.NullString

	// Declation for basic field xlsheetDB.MaxRow {{BasicKind}} (to be completed)
	MaxRow_Data sql.NullInt64

	// Declation for basic field xlsheetDB.MaxCol {{BasicKind}} (to be completed)
	MaxCol_Data sql.NullInt64

	// Declation for basic field xlsheetDB.NbRows {{BasicKind}} (to be completed)
	NbRows_Data sql.NullInt64

	// Implementation of a reverse ID for field XLFile{}.Sheets []*XLSheet
	XLFile_SheetsDBID sql.NullInt64
	XLFile_SheetsDBID_Index sql.NullInt64

	// end of insertion
}

// XLSheetDB describes a xlsheet in the database
//
// It incorporates all fields : from the model, from the generated field for the API and the GORM ID
//
// swagger:model xlsheetDB
type XLSheetDB struct {
	gorm.Model

	XLSheetAPI
}

// XLSheetDBs arrays xlsheetDBs
// swagger:response xlsheetDBsResponse
type XLSheetDBs []XLSheetDB

// XLSheetDBResponse provides response
// swagger:response xlsheetDBResponse
type XLSheetDBResponse struct {
	XLSheetDB
}

type BackRepoXLSheetStruct struct {
	// stores XLSheetDB according to their gorm ID
	Map_XLSheetDBID_XLSheetDB *map[uint]*XLSheetDB

	// stores XLSheetDB ID according to XLSheet address
	Map_XLSheetPtr_XLSheetDBID *map[*models.XLSheet]uint

	// stores XLSheet according to their gorm ID
	Map_XLSheetDBID_XLSheetPtr *map[uint]*models.XLSheet

	db *gorm.DB
}

// BackRepoXLSheet.Init set up the BackRepo of the XLSheet
func (backRepoXLSheet *BackRepoXLSheetStruct) Init(db *gorm.DB) (Error error) {

	if backRepoXLSheet.Map_XLSheetDBID_XLSheetPtr != nil {
		err := errors.New("In Init, backRepoXLSheet.Map_XLSheetDBID_XLSheetPtr should be nil")
		return err
	}

	if backRepoXLSheet.Map_XLSheetDBID_XLSheetDB != nil {
		err := errors.New("In Init, backRepoXLSheet.Map_XLSheetDBID_XLSheetDB should be nil")
		return err
	}

	if backRepoXLSheet.Map_XLSheetPtr_XLSheetDBID != nil {
		err := errors.New("In Init, backRepoXLSheet.Map_XLSheetPtr_XLSheetDBID should be nil")
		return err
	}

	tmp := make(map[uint]*models.XLSheet, 0)
	backRepoXLSheet.Map_XLSheetDBID_XLSheetPtr = &tmp

	tmpDB := make(map[uint]*XLSheetDB, 0)
	backRepoXLSheet.Map_XLSheetDBID_XLSheetDB = &tmpDB

	tmpID := make(map[*models.XLSheet]uint, 0)
	backRepoXLSheet.Map_XLSheetPtr_XLSheetDBID = &tmpID

	backRepoXLSheet.db = db
	return
}

// BackRepoXLSheet.CommitPhaseOne commits all staged instances of XLSheet to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoXLSheet *BackRepoXLSheetStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for xlsheet := range stage.XLSheets {
		backRepoXLSheet.CommitPhaseOneInstance(xlsheet)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, xlsheet := range *backRepoXLSheet.Map_XLSheetDBID_XLSheetPtr {
		if _, ok := stage.XLSheets[xlsheet]; !ok {
			backRepoXLSheet.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoXLSheet.CommitDeleteInstance commits deletion of XLSheet to the BackRepo
func (backRepoXLSheet *BackRepoXLSheetStruct) CommitDeleteInstance(id uint) (Error error) {

	xlsheet := (*backRepoXLSheet.Map_XLSheetDBID_XLSheetPtr)[id]

	// xlsheet is not staged anymore, remove xlsheetDB
	xlsheetDB := (*backRepoXLSheet.Map_XLSheetDBID_XLSheetDB)[id]
	query := backRepoXLSheet.db.Unscoped().Delete(&xlsheetDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	delete((*backRepoXLSheet.Map_XLSheetPtr_XLSheetDBID), xlsheet)
	delete((*backRepoXLSheet.Map_XLSheetDBID_XLSheetPtr), id)
	delete((*backRepoXLSheet.Map_XLSheetDBID_XLSheetDB), id)

	return
}

// BackRepoXLSheet.CommitPhaseOneInstance commits xlsheet staged instances of XLSheet to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoXLSheet *BackRepoXLSheetStruct) CommitPhaseOneInstance(xlsheet *models.XLSheet) (Error error) {

	// check if the xlsheet is not commited yet
	if _, ok := (*backRepoXLSheet.Map_XLSheetPtr_XLSheetDBID)[xlsheet]; ok {
		return
	}

	// initiate xlsheet
	var xlsheetDB XLSheetDB
	xlsheetDB.XLSheet = *xlsheet

	query := backRepoXLSheet.db.Create(&xlsheetDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*backRepoXLSheet.Map_XLSheetPtr_XLSheetDBID)[xlsheet] = xlsheetDB.ID
	(*backRepoXLSheet.Map_XLSheetDBID_XLSheetPtr)[xlsheetDB.ID] = xlsheet
	(*backRepoXLSheet.Map_XLSheetDBID_XLSheetDB)[xlsheetDB.ID] = &xlsheetDB

	return
}

// BackRepoXLSheet.CommitPhaseTwo commits all staged instances of XLSheet to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoXLSheet *BackRepoXLSheetStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, xlsheet := range *backRepoXLSheet.Map_XLSheetDBID_XLSheetPtr {
		backRepoXLSheet.CommitPhaseTwoInstance(backRepo, idx, xlsheet)
	}

	return
}

// BackRepoXLSheet.CommitPhaseTwoInstance commits {{structname }} of models.XLSheet to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoXLSheet *BackRepoXLSheetStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, xlsheet *models.XLSheet) (Error error) {

	// fetch matching xlsheetDB
	if xlsheetDB, ok := (*backRepoXLSheet.Map_XLSheetDBID_XLSheetDB)[idx]; ok {

		{
			{
				// insertion point for fields commit
				xlsheetDB.Name_Data.String = xlsheet.Name
				xlsheetDB.Name_Data.Valid = true

				xlsheetDB.MaxRow_Data.Int64 = int64(xlsheet.MaxRow)
				xlsheetDB.MaxRow_Data.Valid = true

				xlsheetDB.MaxCol_Data.Int64 = int64(xlsheet.MaxCol)
				xlsheetDB.MaxCol_Data.Valid = true

				xlsheetDB.NbRows_Data.Int64 = int64(xlsheet.NbRows)
				xlsheetDB.NbRows_Data.Valid = true

				// commit a slice of pointer translates to update reverse pointer to XLRow, i.e.
				index_Rows := 0
				for _, xlrow := range xlsheet.Rows {
					if xlrowDBID, ok := (*backRepo.BackRepoXLRow.Map_XLRowPtr_XLRowDBID)[xlrow]; ok {
						if xlrowDB, ok := (*backRepo.BackRepoXLRow.Map_XLRowDBID_XLRowDB)[xlrowDBID]; ok {
							xlrowDB.XLSheet_RowsDBID.Int64 = int64(xlsheetDB.ID)
							xlrowDB.XLSheet_RowsDBID.Valid = true
							xlrowDB.XLSheet_RowsDBID_Index.Int64 = int64(index_Rows)
							index_Rows = index_Rows + 1
							xlrowDB.XLSheet_RowsDBID_Index.Valid = true
							if q := backRepoXLSheet.db.Save(&xlrowDB); q.Error != nil {
								return q.Error
							}
						}
					}
				}

			}
		}
		query := backRepoXLSheet.db.Save(&xlsheetDB)
		if query.Error != nil {
			return query.Error
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown XLSheet intance %s", xlsheet.Name))
		return err
	}

	return
}

// BackRepoXLSheet.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One is the creation of instance in the stage
//
// NOTE: the is supposed to have been reset before
//
func (backRepoXLSheet *BackRepoXLSheetStruct) CheckoutPhaseOne() (Error error) {

	xlsheetDBArray := make([]XLSheetDB, 0)
	query := backRepoXLSheet.db.Find(&xlsheetDBArray)
	if query.Error != nil {
		return query.Error
	}

	// copy orm objects to the the map
	for _, xlsheetDB := range xlsheetDBArray {
		backRepoXLSheet.CheckoutPhaseOneInstance(&xlsheetDB)
	}

	return
}

// CheckoutPhaseOneInstance takes a xlsheetDB that has been found in the DB, updates the backRepo and stages the
// models version of the xlsheetDB
func (backRepoXLSheet *BackRepoXLSheetStruct) CheckoutPhaseOneInstance(xlsheetDB *XLSheetDB) (Error error) {

	// if absent, create entries in the backRepoXLSheet maps.
	xlsheetWithNewFieldValues := xlsheetDB.XLSheet
	if _, ok := (*backRepoXLSheet.Map_XLSheetDBID_XLSheetPtr)[xlsheetDB.ID]; !ok {

		(*backRepoXLSheet.Map_XLSheetDBID_XLSheetPtr)[xlsheetDB.ID] = &xlsheetWithNewFieldValues
		(*backRepoXLSheet.Map_XLSheetPtr_XLSheetDBID)[&xlsheetWithNewFieldValues] = xlsheetDB.ID

		// append model store with the new element
		xlsheetWithNewFieldValues.Stage()
	}
	xlsheetDBWithNewFieldValues := *xlsheetDB
	(*backRepoXLSheet.Map_XLSheetDBID_XLSheetDB)[xlsheetDB.ID] = &xlsheetDBWithNewFieldValues

	return
}

// BackRepoXLSheet.CheckoutPhaseTwo Checkouts all staged instances of XLSheet to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoXLSheet *BackRepoXLSheetStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, xlsheetDB := range *backRepoXLSheet.Map_XLSheetDBID_XLSheetDB {
		backRepoXLSheet.CheckoutPhaseTwoInstance(backRepo, xlsheetDB)
	}
	return
}

// BackRepoXLSheet.CheckoutPhaseTwoInstance Checkouts staged instances of XLSheet to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoXLSheet *BackRepoXLSheetStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, xlsheetDB *XLSheetDB) (Error error) {

	xlsheet := (*backRepoXLSheet.Map_XLSheetDBID_XLSheetPtr)[xlsheetDB.ID]
	_ = xlsheet // sometimes, there is no code generated. This lines voids the "unused variable" compilation error
	{
		{
			// insertion point for checkout, i.e. update of fields of stage instance from fields of back repo instances
			//
			xlsheet.Name = xlsheetDB.Name_Data.String

			xlsheet.MaxRow = int(xlsheetDB.MaxRow_Data.Int64)

			xlsheet.MaxCol = int(xlsheetDB.MaxCol_Data.Int64)

			xlsheet.NbRows = int(xlsheetDB.NbRows_Data.Int64)

			// parse all XLRowDB and redeem the array of poiners to XLSheet
			// first reset the slice
			xlsheet.Rows = xlsheet.Rows[:0]
			for _, XLRowDB := range *backRepo.BackRepoXLRow.Map_XLRowDBID_XLRowDB {
				if XLRowDB.XLSheet_RowsDBID.Int64 == int64(xlsheetDB.ID) {
					XLRow := (*backRepo.BackRepoXLRow.Map_XLRowDBID_XLRowPtr)[XLRowDB.ID]
					xlsheet.Rows = append(xlsheet.Rows, XLRow)
				}
			}
			
			// sort the array according to the order
			sort.Slice(xlsheet.Rows, func(i, j int) bool {
				xlrowDB_i_ID := (*backRepo.BackRepoXLRow.Map_XLRowPtr_XLRowDBID)[xlsheet.Rows[i]]
				xlrowDB_j_ID := (*backRepo.BackRepoXLRow.Map_XLRowPtr_XLRowDBID)[xlsheet.Rows[j]]

				xlrowDB_i := (*backRepo.BackRepoXLRow.Map_XLRowDBID_XLRowDB)[xlrowDB_i_ID]
				xlrowDB_j := (*backRepo.BackRepoXLRow.Map_XLRowDBID_XLRowDB)[xlrowDB_j_ID]

				return xlrowDB_i.XLSheet_RowsDBID_Index.Int64 < xlrowDB_j.XLSheet_RowsDBID_Index.Int64
			})

		}
	}
	return
}

// CommitXLSheet allows commit of a single xlsheet (if already staged)
func (backRepo *BackRepoStruct) CommitXLSheet(xlsheet *models.XLSheet) {
	backRepo.BackRepoXLSheet.CommitPhaseOneInstance(xlsheet)
	if id, ok := (*backRepo.BackRepoXLSheet.Map_XLSheetPtr_XLSheetDBID)[xlsheet]; ok {
		backRepo.BackRepoXLSheet.CommitPhaseTwoInstance(backRepo, id, xlsheet)
	}
}

// CommitXLSheet allows checkout of a single xlsheet (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutXLSheet(xlsheet *models.XLSheet) {
	// check if the xlsheet is staged
	if _, ok := (*backRepo.BackRepoXLSheet.Map_XLSheetPtr_XLSheetDBID)[xlsheet]; ok {

		if id, ok := (*backRepo.BackRepoXLSheet.Map_XLSheetPtr_XLSheetDBID)[xlsheet]; ok {
			var xlsheetDB XLSheetDB
			xlsheetDB.ID = id

			if err := backRepo.BackRepoXLSheet.db.First(&xlsheetDB, id).Error; err != nil {
				log.Panicln("CheckoutXLSheet : Problem with getting object with id:", id)
			}
			backRepo.BackRepoXLSheet.CheckoutPhaseOneInstance(&xlsheetDB)
			backRepo.BackRepoXLSheet.CheckoutPhaseTwoInstance(backRepo, &xlsheetDB)
		}
	}
}
